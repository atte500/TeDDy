# TeDDy: Design by Contract & Test-Driven Development with AI

TeDDy is an AI-assisted coding paradigm that pairs a strategic **Architect AI** with a tactical **Developer AI** to build robust, verifiable software. It counters the instability of "agent-mode" AI development by enforcing engineering discipline through a workflow inspired by Design by Contract (DbC) principles and grounded in Test-Driven Development (TDD) practices.

## The Problem: The AI Coding "Slot Machine"

Modern AI coding assistants are powerful but unpredictable. The experience often feels like playing a slot machine:
- **Initial Wins:** The first few code generations are impressive, leading to a feeling of rapid progress.
- **Rapid Decay:** This initial velocity quickly grinds to a halt as the complexity grows. You lose control of the code, and the cost of change skyrockets.
- **Compounding Errors:** LLMs tend to "guess" the final code without incremental verification. This leads to compounding errors that are difficult to untangle.

The 2025 DORA report on AI-assisted development confirms this observation: **software delivery instability leads to higher change failure rates and more rework.**

## The Solution: Quality by Design

The core issue is that software development is an iterative, sequential process. Unlike highly parallelizable problems where scale is the primary solution, software's main bottleneck is the **sequential, cognitive work of engineering**: asking the right questions, defining clear boundaries, and validating assumptions.

We take inspiration from the **Toyota Production System (TPS)**, which revolutionized manufacturing by shifting from end-of-line quality control to a "built-in quality" mindset.

Two key principles of TPS apply directly to software:

1.  **Jidoka (Autonomation):** *Stop the line immediately when a defect is found.* In software, a "defect" is a wrong assumption. Test-Driven Development (TDD) is our implementation of Jidoka, preventing flawed code from ever being integrated.
2.  **Poka-Yoke (Mistake-Proofing):** *Design processes so errors can't be made in the first place.* Design by Contract is our Poka-Yoke. By defining clear "seams" and contracts between software components, we mistake-proof the architecture.

The objective is to improve long-term efficiency based on the prinicple that **speed is a byproduct of quality.**

## The TeDDy Workflow: Architect & Developer

TeDDy structures the development process around two distinct AI personas, each with a specific prompt and a clear mandate.

### 1. The Architect (Design by Contract)

The Architect's role is to manage complexity and define the engineering blueprint. It follows a structured workflow to establish clear, verifiable contracts before any implementation code is written.

> **`Prompts/architect.xml`**: A high-level planner that defines the public contract (`README.md`), the internal architecture (`ARCHITECTURE.md`), and the specific contracts for each layer of the application. **Its output is documentation.**

### 2. The Developer (Test-Driven Development)

The Developer's role is to implement the Architect's plan. It follows a strict, outside-in TDD workflow, ensuring that every line of code is written to satisfy a failing test, which in turn satisfies an architectural contract.

> **`Prompts/dev.xml`**: A hands-on implementer that executes the Architect's plan. It works in nested Red-Green-Refactor loops, starting with a failing end-to-end test and progressively implementing the system layer by layer. **Its output is code and tests.**

## How to Use TeDDy

1.  **Phase 1: Architecture:**
    - Start a chat session with [Google AI Studio](https://aistudio.google.com/).
    - Provide the content of `Prompts/architect.xml` as the system prompt.
    - Give the Architect a high-level business requirement.
    - Iterate with the Architect until the public `README.md` and internal `ARCHITECTURE.md` are approved and all vertical slices and layer contracts are defined.

2.  **Phase 2: Development:**
    - Start a new chat session.
    - Provide the content of `Prompts/dev.xml` as the system prompt.
    - Provide the architectural documents generated by the Architect.
    - Instruct the Developer to begin implementing the first vertical slice.

## Conceptual Groundwork

For a detailed walkthrough of the concepts and principles behind TeDDy, please see the video overview:
- **[Link to Conceptual Overview Video]** *(Please provide the link)*

## Recommended Tooling

To streamline the manual steps of the TeDDy workflow, we recommend the following VS Code extensions:

-   **[Copy4AI](https://marketplace.visualstudio.com/items?itemName=LeonKohli.snapsource):** Quickly copy the contents of multiple files and the project structure to your clipboard to provide context to the AI.
-   **[PatchPilot](https://marketplace.visualstudio.com/items?itemName=patchpilot.patch-pilot):** Apply code changes provided by the AI in the `diff` format directly into your local files.

## Understanding the AI's Plans

The Architect and Developer AIs operate by generating structured **Plans**. Each plan has a clear **Goal** and a series of **Actions**. Your role is to act as the executor of these plans, applying the changes to your local workspace.

### Plan Types

Each persona has a specific set of plans they can generate:

#### Architect Plans
-   **`Information Gathering`**: Used to read files, ask you questions, or research external topics to fill knowledge gaps.
-   **`Spike`**: A time-boxed experiment to resolve a specific technical or functional unknown (e.g., testing a library) before committing to a design. The output is disposable.
-   **`EDIT Documentation`**: The primary plan type for creating and updating the canonical architecture documents in the `/docs/` directory.

#### Developer Plans
-   **`Information Gathering`**: Used to read architectural documents or ask for clarification.
-   **`RED Phase`**: To write a single new *failing* test (End-to-End, Layer, or Unit).
-   **`GREEN Phase`**: To write the *minimum* amount of implementation code required to make the current failing test pass.
-   **`REFACTOR Phase`**: To improve the internal structure of the code without changing its external behavior, done only when all tests are passing.
-   **`Version Control`**: To execute `git` commands for staging and committing code after a successful refactor cycle.

### Action Reference

These are the specific actions the AI can include in a plan:

-   **`CREATE FILE`**: Creates a new file with the specified content.
-   **`EDIT FILE`**: Modifies an existing file using a `FIND`/`REPLACE` block or a `diff` patch.
-   **`APPEND TO FILE`**: Adds content to the end of an existing file.
-   **`DELETE FILE`**: Removes a file, typically for cleaning up spike artifacts.
-   **`READ FILE`**: Reads the content of a file to gain context.
-   **`EXECUTE`**: Runs a shell command (e.g., to run tests or `git status`).
-   **`RESEARCH`**: Asks a set of specific questions. For now, you can copy the research request and provide it to another AI (like Gemini, Perplexity, etc.) to get the answers.
-   **`CHAT WITH USER`**: The AI requires your feedback, approval, or specific information.

## Roadmap & Limitations

-   **Google AI Studio:** The current prompts are tailored for Google AI Studio and may require adjustments for other models and interfaces. The long-term goal is to make the prompts more model-agnostic.
-   **Manual Execution:** Plans generated by the AIs must be executed manually. The "Recommended Tooling" section above helps ease this process.
-   **UI Integration:** We plan to move beyond manual execution by integrating the TeDDy workflow directly into an open-source platform like **[LibreChat](https://www.librechat.ai/)**. This will allow for a more seamless, integrated user experience.