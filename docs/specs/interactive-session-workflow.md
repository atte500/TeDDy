# Interactive Session Workflow Specification

## 1. Overview

This document specifies the design and behavior of the interactive, file-based session workflow for TeDDy. The goal is to create a robust, stateless, and versionable workflow that provides a complete, auditable history of the AI collaboration.

The core of this workflow is the **Context-Centric Lifecycle**: a dedicated `input.md` file serves as the single, complete input for the AI's planning phase for each turn. This decouples the historical `report.md` from the forward-looking planning process, creating a clear, stateless flow of information from one turn to the next.

## 2. The Turn Lifecycle

The entire session is a sequence of "turns," where each turn consists of a planning phase and an execution phase, including an explicit user approval step.

```mermaid
graph TD
    subgraph "Current Turn (N)"
        A("`teddy plan` or `resume`") --> B["Generate `N/input.md`<br>(implicit)"];
        B & C["`N/system_prompt.xml`"] --> D["LLM generates<br/>`N/plan.md`"];

        D --> E("`teddy execute`");

        E -- "Executes plan actions on" --> Workspace([Workspace Files]);
        E -- "Generates" --> F["`N/report.md` (log)"];
        E -- "Prepares" --> G["`N+1/` directory"];
    end

    subgraph "Plan Actions' Impact on Next Turn (N+1)"
        subgraph "plan.md"
            direction LR
            H["`READ` action"];
            I["`PRUNE` action"];
            J["`INVOKE` action"];
        end
        H -- "adds to" --> K["`N+1/turn.context`"];
        I -- "removes from" --> K;
        J -- "overwrites" --> L["`N+1/system_prompt.xml`"];
    end

    E -- contains --> H;
    E -- contains --> I;
    E -- contains --> J;

    G & K & L --> M("Next turn is ready");
```

## 3. The Core Directory Structure

The system uses a top-level `.teddy/` directory to store all persistent data. The turn directories are now simplified to reflect the new report-centric model.

```
.teddy/
├── memos.yaml
└── 20260124-add-user-auth/      # Session Directory
    └── 01/                      # Turn 1
        ├── input.md
        ├── system_prompt.xml
        ├── plan.md
        └── report.md
```

## 4. Core Artifacts

-   **`input.md`**: A rich, structured Markdown file generated by the `teddy context` command. It serves as the complete, self-contained worldview for the AI's planning phase. See the [Context Payload Format Specification](./context-payload-format.md) for details.
-   **`system_prompt.xml`**: The system prompt providing the core instructions to the AI for the planning phase.
-   **`plan.md`**: The raw markdown file generated by the AI for the current turn. It is the immutable input to the `execute` command.
-   **`report.md`**: The factual record of the execution of `plan.md`. It is the immutable output of the `execute` command.
-   **`.teddy/memos.yaml`**: A global YAML file for the AI's long-term memory.
    -   **Example Format:**
        ```yaml
        - All API endpoints must be documented in OpenAPI spec.
        - Use 'pnpm' for all package management.
        ```

## 5. Context Management

Context is determined by a cascading hierarchy of files, which are then snapshotted into the `report.md` for the AI to consume.

1.  **Static Context (User-Managed):**
    -   `.teddy/global.context`: Defines file paths included in *every* session.
    -   `<session>/session.context`: Defines file paths relevant for the entire session.
2.  **Dynamic Context (AI-Managed):**
    -   `turn.context`: Contains the file paths for the current turn's "working set." This file is not edited directly by the user.
3.  **The Workflow:**
    -   The AI manages its working context via the `READ` (to add) and `PRUNE` (to remove) actions in its `plan.md`.
    -   During `teddy execute`, these actions modify the `turn.context` file for the *next* turn, ensuring all context changes are forward-looking.
    -   The AI's worldview is generated explicitly via the `teddy context` command, which reads all context files (`global.context`, `session.context`, `turn.context`) and assembles the complete `input.md` payload.

## 6. CLI Command Specification

This section defines the top-level commands for managing the session workflow.

---

### `teddy context`

Assembles the complete `input.md` for the current turn. This is the primary way to prepare the AI's worldview.

-   **Behavior:**
    1.  Operates within the context of the current turn directory (e.g., `01/`).
    2.  Aggregates context from `.teddy/global.context`, `<session>/session.context`, and the current turn's `turn.context` file.
    3.  Generates the `input.md` file according to the [Context Payload Format Specification](./context-payload-format.md).

---

### `teddy new <name>`

Initializes a new session directory and bootstraps it for "Turn 1".

-   **Arguments:**
    -   `<name>`: A descriptive, kebab-case name for the session (e.g., "implement-auth-flow").
-   **Behavior:**
    1.  Creates the session directory and the `01/` turn directory.
    2.  Creates the session-specific context file at `<session>/session.context`.
    3.  Uses `teddy get-prompt` to fetch the default agent prompt and saves it as `01/system_prompt.xml`.
    4.  The session is now ready. The user's next step is typically to run `teddy context` to generate the initial `input.md`.
    5.  Outputs the path to the new session directory.

---

### `teddy plan`

Generates a `plan.md` within a turn directory.

-   **Options:**
    -   `-m, --message <message>`: The user's prompt/instruction for this turn.
-   **Behavior:**
    1.  Operates within the context of the current turn directory (e.g., `01/`).
    2.  **Implicitly runs the `teddy context` logic** to generate an up-to-date `input.md` file.
    3.  Reads the content of the newly generated `input.md` and the existing `system_prompt.xml`.
    4.  Passes the user's message along with the content of these two files to the LLM.
    5.  **Receives the raw Markdown response from the LLM and automatically runs the `preprocess` logic on it to correct any ambiguous code fencing.**
    6.  Saves the **sanitized, corrected response** as `01/plan.md`.

---

### `teddy execute [plan_file]`

Executes a plan, generates a report, and prepares the subsequent turn based on a precise, deterministic algorithm.

-   **Arguments:**
    -   `[plan_file]`: Path to a `plan.md` file (e.g., `01/plan.md`).
-   **Options:**
    -   `-y`: (Optional) Auto-approve all actions.

#### The Turn Transition Algorithm
The `teddy execute` command creates the *next* turn (`T_next`) based on the state of the *current* turn (`T_current`) and its `plan.md`. The following algorithm is executed in order.

1.  **Validation Phase:** The plan is first validated against a series of pre-flight checks. See Section 8 for details. If validation fails, the command triggers the **Automated Re-plan Loop** (which generates a failure report and initiates a new turn) and then terminates. If validation succeeds, it proceeds to the Approval Phase.
2.  **Approval Phase:** Initiates the interactive **Approval & Execution Phase**. If the plan is not approved, the command terminates.
3.  **Initialize Next Turn (`T_next`):**
    -   Create the `T_next` directory.
    -   **Default State:** `T_next` starts as a direct continuation of `T_current`.
        -   Copy `T_current/system_prompt.xml` to `T_next/`.
        -   Copy `T_current/turn.context` to `T_next/`.
        -   Create `T_next/meta.yaml` with `turn_id`, `parent_turn_id` pointing to `T_current`'s ID, and `caller_turn_id` copied from `T_current`.
4.  **Apply Standard Context Changes from `plan.md`:**
    -   Process all standard actions in `T_current/plan.md`:
        -   For each `READ` action, add its resource path to `T_next/turn.context`.
        -   For each `PRUNE` action, remove its resource path from `T_next/turn.context`.
5.  **Apply Special Action Overrides:**
    -   If `T_current/plan.md` contains an `INVOKE` or `CONCLUDE` action, it overrides the default state.
    -   **If `INVOKE`:**
        -   **Context:** `T_next/turn.context` is wiped and replaced with files from `Handoff Resources`.
        -   **Agent:** `T_next/system_prompt.xml` is overwritten with the invoked agent's prompt.
        -   **Ledger:** `caller_turn_id` in `T_next/meta.yaml` is set to `T_current`'s ID.
    -   **If `CONCLUDE`:**
        -   Find the original `caller_turn_id` from `T_current/meta.yaml`.
        -   **Context:** `T_next/turn.context` is replaced with the *caller's* context, then files from `Handoff Resources` are appended.
        -   **Agent:** `T_next/system_prompt.xml` is overwritten with the *caller's* prompt.
        -   **Ledger:** `parent_turn_id` in `T_next/meta.yaml` is set to the `caller_turn_id`, and `caller_turn_id` is cleared.
6.  **Finalize and Report:**
    -   **Generate Report:** The factual `T_current/report.md` is generated based on the successful execution of the approved plan.
    -   **Append Report:** The path to the newly generated `T_current/report.md` is always appended to `T_next/turn.context`.

---

### `teddy resume`

The primary "continue" command for a session. It intelligently determines the next action.

-   **Behavior:**
    1.  Identifies the latest turn directory in the current session.
    2.  **State Check:**
        -   If the turn has a `plan.md` but no `report.md`, it behaves like `teddy execute`.
        -   If the turn is complete (has a `report.md`), it prompts the user for a new message and then behaves like `teddy plan` for the *next* turn (which includes implicitly generating a new `input.md`).

---

## 7. Approval & Execution Phase

This phase implements a two-tiered workflow to give the user both speed and granular control.

**Tier 1: High-Level Summary & Prompt**
The command first presents a high-level summary of all proposed state changes (`Memos`) and the actions to be performed.

*Example UI:*
```text
▶ Reviewing Plan: "Bootstrap New Project Component"
--------------------------------------------------------------------

 memos.yaml:
  [+] ADD:    All new components must have a core.py file. # Establish a new convention.

 Action Plan:
  - CREATE: 1 file
  - EDIT:   1 file
  - EXECUTE: 1 command

--------------------------------------------------------------------
Execute this plan? (a)pprove all / (r)eview full plan / (m)odify / (s)kip / (q)uit ›
```
-   `(a)pprove all`: Executes the entire plan non-interactively.
-   `(r)eview full plan`: Opens the complete `plan.md` file in the configured previewer (read-only) for a full review. After the previewer is closed, the user is returned to this prompt.
-   `(m)odify`: Enters Tier 2 for granular control.
-   `(s)kip`: Aborts execution and prompts for a message to generate a new plan.
-   `(q)uit`: Exits the session.

**Tier 2: Interactive "Modify & Preview" Mode**
If the user selects `(m)odify`, they enter an interactive checklist to configure the plan before execution. The tool will execute all checked items as a single batch, in their original order, once the user confirms their selections.

*Example UI:*
```text
Use [↑/↓] to navigate, [enter] to toggle, [a] to toggle all, [p] to preview details, [s] to confirm.

- Memos
 │
 └─[✓] [+] ADD: All new components must have a core.py file.

- Action Plan
 │
 ├─[ ] CREATE: src/components/new_component/core.py
 ├─[✓] EDIT:   pyproject.toml
 └─[ ] EXECUTE: poetry lock
```
-   **Controls:** Users can navigate the list, toggle items on/off with the spacebar, and press `[enter]` to confirm and execute the configured plan.

-   **Interactive Previews & Manual Editing:** When any item is highlighted, pressing `(p)` will trigger the **"Context-Aware Editing"** workflow, allowing for both preview and direct manual modification of the action. If a user makes changes to an action, it will be marked with a `*modified` tag in the UI. To ensure a complete audit trail, the `report.md` will explicitly note any user modifications, and the final executed action will reflect the user's changes, not the AI's original proposal.

    The behavior of the `(p)` key is context-dependent:

    -   **For `CREATE` actions (The "Save As" Workflow):**
        1.  The tool immediately opens the proposed file content in a temporary file using the user's configured external editor (non-blocking).
        2.  Simultaneously, the terminal displays a message and prompts for the file path:
            ```text
            Your editor has been opened to preview the new file's content. You may edit it directly in this preview.

            File path: [src/new_component.py]
            Press Enter to confirm, or type a new path ›
            ```
        3.  After the path is confirmed, a final confirmation prompt (`Have you finished editing and saved the file content? (y/n)`) appears. This user confirmation acts as the synchronization signal.
        4.  Once confirmed, the tool uses the (potentially modified) path and content for execution.

    -   **For `EDIT` actions:**
        1.  The tool creates a temporary file representing the **proposed final version** of the target file (i.e., the original file with the AI's changes already applied).
        2.  This temporary file is opened in the user's external editor (non-blocking).
        3.  Simultaneously, the terminal displays a message and a confirmation prompt, including the path of the file being edited for clarity:
            ```text
            Editing: [pyproject.toml]

            Your editor has been opened to preview the proposed changes. You may edit the file directly in this preview to make final adjustments.

            Have you finished editing and saved the file? (y/n) ›
            ```
        4.  Once confirmed, the tool calculates the final changes and updates the action. The final `diff` is what will be recorded in the `report.md`.

    -   **For simple actions (`EXECUTE`, `RESEARCH`, etc.):**
        1.  A simple, in-terminal view of the action's content (e.g., the shell command) is displayed.
        2.  The user is prompted to `(e)dit` or `(c)lose`. Selecting edit provides a simple input field to change the content.

    -   **For read-only actions (`READ`, `PRUNE`):**
        1.  A simple preview of the target resource is shown without an option to edit.

## 8. Plan Validation & Automated Re-planning

To enhance reliability and reduce manual correction cycles, `teddy` incorporates a robust pre-flight validation system for all plans before execution. If a plan fails validation, it triggers an automated re-planning loop that instructs the AI to correct its own plan.

### 8.1 The Validation Phase

This phase occurs at the beginning of the `teddy execute` command, before the user is prompted for approval. It acts as a gatekeeper, ensuring that only valid and executable plans are presented to the user.

### 8.2 Pre-flight Checks

The following checks are performed on the `plan.md` and the current state of the workspace:

#### General Checks
-   **Parsing:** The `plan.md` must be well-formed and parsable.

#### Memo Checks
-   **`[+] ADD`**: The memo to be added must not already exist in `memos.yaml` to prevent duplicates.
-   **`[-] REMOVE`**: The memo to be removed must exist exactly as specified in `memos.yaml`.

#### Action Checks
-   **`CREATE`**: The target file path must not already exist.
-   **`EDIT`**:
    -   The target file path must exist.
    -   The target file must be listed in the current `turn.context`.
    -   Each `FIND` block must match a unique, single block of text in the target file. Failures occur for zero matches or multiple matches.
    -   The `REPLACE` block must be different than the `FIND` block it's replacing.
-   **`PRUNE`**: The target file must be listed in the current `turn.context`.

### 8.3 The Automated Re-plan Loop

If any of the pre-flight checks fail, the following automated process is initiated to preserve a full audit trail while providing the AI with the context to self-correct.

1.  **Log the Failure:**
    -   The `teddy execute` command generates a `T_current/report.md` file detailing the specific validation errors that occurred. This preserves the immutable record of the failed attempt.
2.  **Prepare Feedback Payload:**
    -   The system prepares a rich, structured feedback message for the AI. This message is ephemeral and is not stored in the persistent `turn.context`. The message includes:
        -   The list of specific validation errors.
        -   The full, verbatim content of the original, faulty `plan.md`.
    -   *Example Message:*
        ```markdown
        The previous plan failed validation. Please review the errors and the original plan, then generate a corrected version.

        ## Validation Errors:
        - `EDIT` on `pyproject.toml`: FIND block did not match.

        ## Original Faulty Plan:
        ````markdown
        # Original Plan Title
        ... (full content of the failed plan) ...
        ````
        ````
3.  **Initiate Next Turn (with Exception):**
    -   The system creates the `T_next` directory using the standard Turn Transition Algorithm, but with **one critical exception**: the path to the failure report (`T_current/report.md`) is **NOT** appended to `T_next/turn.context`. This keeps the AI's working context clean.
4.  **Automatic Re-plan:**
    -   The system automatically invokes `teddy plan` within the `T_next` directory, passing the entire feedback payload from Step 2 as the user's message (`--message`).
5.  **Halt Execution & Handoff:**
    -   The current `teddy execute` command terminates. The user is left in the new turn directory, where the AI is generating a corrected plan. The user's next action is to review the newly generated plan and run `teddy execute` again.

This loop turns the AI into a self-correcting agent, using structured, "just-in-time" feedback to improve its own output without polluting the long-term context or requiring manual user intervention for common, predictable errors.

---

## 9. Implementation Guide & Reference Prototype

An extensive, iterative prototyping process was conducted to validate the UX and de-risk the technical implementation of this feature. The key learnings from this process are captured below, and the final, polished prototype is included as a canonical reference.

#### Key Implementation Learnings

*   **Component Choice:** The `textual.widgets.Tree` is the correct primary component for the UI, as it natively handles the required hierarchical display.
*   **State Management:** Selection state must be managed by updating a boolean in the `TreeNode.data` dictionary. The UI is then updated by re-rendering the node's label to simulate a checkbox (e.g., `[✓]` or `[ ]`). Direct embedding of widgets like `Checkbox` into a `Tree` is not supported.
*   **Keybindings:** `Ctrl`-based keybindings (`ctrl+s`, `ctrl+a`) proved unreliable across different terminal environments. The final, validated keybinding scheme uses single, non-conflicting letters:
    *   `a` for "toggle all".
    *   `s` for "submit/confirm".
*   **Toggle-All Logic:** The "toggle all" action must use a "select all / unselect all" model. The correct logic is: if *any* item is currently unselected, the action selects all. If *all* items are already selected, it unselects all.
*   **String Manipulation:** When updating node labels, prefixes (`[✓] `) must be stripped robustly to avoid bugs where prefixes are duplicated. A helper function to get the "raw" label text is the recommended approach.

---

## 10. Configuration (`.teddy/config.yaml`)

User-specific behavior for the `teddy` tool can be defined in an optional `.teddy/config.yaml` file.

-   **`preview_command`**: (Optional) A string defining the shell command to use for the `(p)review` feature. The tool will write the preview content to a temporary file and pass its path as the final argument to this command.

    -   *Example for Neovim:* `preview_command: "nvim -R"`
    -   *Example for VS Code:* `preview_command: "code"` # Note: Use without `--wait` for a non-blocking preview.

-   **Previewer Fallback Logic:** When the user triggers a preview, the tool will use the following logic to determine how to display it:
    1.  **Configured Editor:** If `preview_command` is set in `.teddy/config.yaml`, it will be used.
    2.  **Visual Studio Code (Default):** If the `code` command is available in the system's `PATH`, it will be used as the default external editor.
    3.  **In-Terminal Display (Fallback):** If neither of the above is available, a colorized diff or formatted content will be printed directly to the terminal.

---

### `teddy preprocess [plan_file]`

A utility command that sanitizes a Markdown plan by correcting ambiguous code fencing. It ensures that plans from any source are safe to parse and execute.

-   **Arguments:**
    -   `[plan_file]`: (Optional) The path to a plan file. If provided, the file will be modified **in-place**.
-   **Options:**
    -   `--no-copy`: (Optional) If running in clipboard mode, this flag prevents the corrected output from being copied back to the clipboard.
-   **Behavior:**
    -   **File Mode:** When `[plan_file]` is provided, the command reads the file, corrects any ambiguous fences, and writes the sanitized content back to the original file.
    -   **Clipboard Mode:** When no arguments are provided, the command reads from the system clipboard, prints the corrected content to `stdout`, and copies the corrected content back to the clipboard.

---

*(The `teddy branch` command has been removed. Branching can be easily and explicitly achieved by copying a turn directory, for example: `cp -r 02/ 02-branch-01/`.)*
